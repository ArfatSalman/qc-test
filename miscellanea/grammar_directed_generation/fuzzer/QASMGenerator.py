# Generated by Grammarinator 19.3.post90+g583ebca

import itertools

from math import inf
from grammarinator.runtime import *

class QASMGenerator(Generator):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)


    @depthcontrol
    def EOF(self, parent=None):
        pass
    EOF.min_depth = 0

    @depthcontrol
    def mainprog(self, parent=None):
        current = UnparserRule(name='mainprog', parent=parent)
        self._enter_rule(current)
        self.version(parent=current)
        if self._max_depth >= 3:
            for _ in self._model.quantify(current, 0, min=0, max=inf):
                self.statement(parent=current)
        self._exit_rule(current)
        return current
    mainprog.min_depth = 3

    @depthcontrol
    def statement(self, parent=None):
        current = UnparserRule(name='statement', parent=parent)
        self._enter_rule(current)
        choice = self._model.choice(current, 0, [0 if [2, 3, 3, 2, 2, 2, 3, 3, 3][i] > self._max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.decl(parent=current)
        elif choice == 1:
            self.gatedecl(parent=current)
            self.goplist(parent=current)
            UnlexerRule(src='}', parent=current)
        elif choice == 2:
            self.gatedecl(parent=current)
            UnlexerRule(src='}', parent=current)
        elif choice == 3:
            UnlexerRule(src='opaque', parent=current)
            self.ID(parent=current)
            self.idlist(parent=current)
            UnlexerRule(src=';\n', parent=current)
        elif choice == 4:
            UnlexerRule(src='opaque', parent=current)
            self.ID(parent=current)
            UnlexerRule(src='(', parent=current)
            UnlexerRule(src=')', parent=current)
            self.idlist(parent=current)
            UnlexerRule(src=';\n', parent=current)
        elif choice == 5:
            UnlexerRule(src='opaque', parent=current)
            self.ID(parent=current)
            UnlexerRule(src='(', parent=current)
            self.idlist(parent=current)
            UnlexerRule(src=')', parent=current)
            self.idlist(parent=current)
            UnlexerRule(src=';', parent=current)
        elif choice == 6:
            self.qop(parent=current)
        elif choice == 7:
            UnlexerRule(src='if', parent=current)
            UnlexerRule(src='(', parent=current)
            self.ID(parent=current)
            UnlexerRule(src='==', parent=current)
            self.INT(parent=current)
            UnlexerRule(src=')', parent=current)
            self.qop(parent=current)
        elif choice == 8:
            UnlexerRule(src='barrier', parent=current)
            self.anylist(parent=current)
            UnlexerRule(src=';', parent=current)
        self._exit_rule(current)
        return current
    statement.min_depth = 2

    @depthcontrol
    def version(self, parent=None):
        current = UnparserRule(name='version', parent=parent)
        self._enter_rule(current)
        UnlexerRule(src='OPENQASM', parent=current)
        self.REAL(parent=current)
        UnlexerRule(src=';\n\n', parent=current)
        self._exit_rule(current)
        return current
    version.min_depth = 2

    @depthcontrol
    def decl(self, parent=None):
        current = UnparserRule(name='decl', parent=parent)
        self._enter_rule(current)
        choice = self._model.choice(current, 0, [0 if [1, 1][i] > self._max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='qreg', parent=current)
            self.ID(parent=current)
            UnlexerRule(src='[', parent=current)
            self.INT(parent=current)
            UnlexerRule(src=']', parent=current)
            UnlexerRule(src=';\n', parent=current)
        elif choice == 1:
            UnlexerRule(src='creg', parent=current)
            self.ID(parent=current)
            UnlexerRule(src='[', parent=current)
            self.INT(parent=current)
            UnlexerRule(src=']', parent=current)
            UnlexerRule(src=';\n', parent=current)
        self._exit_rule(current)
        return current
    decl.min_depth = 1

    @depthcontrol
    def gatedecl(self, parent=None):
        current = UnparserRule(name='gatedecl', parent=parent)
        self._enter_rule(current)
        choice = self._model.choice(current, 0, [0 if [2, 2, 2][i] > self._max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            UnlexerRule(src='gate', parent=current)
            self.ID(parent=current)
            self.idlist(parent=current)
            UnlexerRule(src='{', parent=current)
        elif choice == 1:
            UnlexerRule(src='gate', parent=current)
            self.ID(parent=current)
            UnlexerRule(src='(', parent=current)
            UnlexerRule(src=')', parent=current)
            self.idlist(parent=current)
            UnlexerRule(src='{', parent=current)
        elif choice == 2:
            UnlexerRule(src='gate', parent=current)
            self.ID(parent=current)
            UnlexerRule(src='(', parent=current)
            self.idlist(parent=current)
            UnlexerRule(src=')', parent=current)
            self.idlist(parent=current)
            UnlexerRule(src='{', parent=current)
        self._exit_rule(current)
        return current
    gatedecl.min_depth = 2

    @depthcontrol
    def goplist(self, parent=None):
        current = UnparserRule(name='goplist', parent=parent)
        self._enter_rule(current)
        if self._max_depth >= 0:
            for _ in self._model.quantify(current, 0, min=1, max=inf):
                choice = self._model.choice(current, 0, [0 if [3, 2][i] > self._max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.uop(parent=current)
                elif choice == 1:
                    UnlexerRule(src='barrier', parent=current)
                    self.idlist(parent=current)
                    UnlexerRule(src=';\n', parent=current)
        self._exit_rule(current)
        return current
    goplist.min_depth = 2

    @depthcontrol
    def qop(self, parent=None):
        current = UnparserRule(name='qop', parent=parent)
        self._enter_rule(current)
        choice = self._model.choice(current, 0, [0 if [3, 2, 2][i] > self._max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.uop(parent=current)
        elif choice == 1:
            UnlexerRule(src='measure', parent=current)
            self.argument(parent=current)
            UnlexerRule(src='->', parent=current)
            self.argument(parent=current)
            UnlexerRule(src=';\n', parent=current)
        elif choice == 2:
            UnlexerRule(src='reset', parent=current)
            self.argument(parent=current)
            UnlexerRule(src=';\n', parent=current)
        self._exit_rule(current)
        return current
    qop.min_depth = 2

    @depthcontrol
    def uop(self, parent=None):
        current = UnparserRule(name='uop', parent=parent)
        self._enter_rule(current)
        choice = self._model.choice(current, 0, [0 if [2, 2, 3, 3, 3][i] > self._max_depth else w for i, w in enumerate([1, 1, 1, 1, 1])])
        if choice == 0:
            UnlexerRule(src='U', parent=current)
            UnlexerRule(src='(', parent=current)
            self.explist(parent=current)
            UnlexerRule(src=')', parent=current)
            self.argument(parent=current)
            UnlexerRule(src=';\n', parent=current)
        elif choice == 1:
            UnlexerRule(src='CX', parent=current)
            self.argument(parent=current)
            UnlexerRule(src=',', parent=current)
            self.argument(parent=current)
            UnlexerRule(src=';\n', parent=current)
        elif choice == 2:
            self.ID(parent=current)
            self.anylist(parent=current)
            UnlexerRule(src=';\n', parent=current)
        elif choice == 3:
            self.ID(parent=current)
            UnlexerRule(src='(', parent=current)
            UnlexerRule(src=')', parent=current)
            self.anylist(parent=current)
            UnlexerRule(src=';\n', parent=current)
        elif choice == 4:
            self.ID(parent=current)
            UnlexerRule(src='(', parent=current)
            self.explist(parent=current)
            UnlexerRule(src=')', parent=current)
            self.anylist(parent=current)
            UnlexerRule(src=';\n', parent=current)
        self._exit_rule(current)
        return current
    uop.min_depth = 2

    @depthcontrol
    def anylist(self, parent=None):
        current = UnparserRule(name='anylist', parent=parent)
        self._enter_rule(current)
        choice = self._model.choice(current, 0, [0 if [2, 2][i] > self._max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.idlist(parent=current)
        elif choice == 1:
            self.mixedlist(parent=current)
        self._exit_rule(current)
        return current
    anylist.min_depth = 2

    @depthcontrol
    def idlist(self, parent=None):
        current = UnparserRule(name='idlist', parent=parent)
        self._enter_rule(current)
        if self._max_depth >= 1:
            for _ in self._model.quantify(current, 0, min=0, max=inf):
                self.ID(parent=current)
                UnlexerRule(src=',', parent=current)
        self.ID(parent=current)
        self._exit_rule(current)
        return current
    idlist.min_depth = 1

    @depthcontrol
    def mixedlist(self, parent=None):
        current = UnparserRule(name='mixedlist', parent=parent)
        self._enter_rule(current)
        choice = self._model.choice(current, 0, [0 if [1, 1, 1][i] > self._max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            if self._max_depth >= 1:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    self.ID(parent=current)
                    UnlexerRule(src='[', parent=current)
                    self.INT(parent=current)
                    UnlexerRule(src=']', parent=current)
                    UnlexerRule(src=',', parent=current)
            self.ID(parent=current)
        elif choice == 1:
            if self._max_depth >= 1:
                for _ in self._model.quantify(current, 1, min=0, max=inf):
                    self.ID(parent=current)
                    UnlexerRule(src='[', parent=current)
                    self.INT(parent=current)
                    UnlexerRule(src=']', parent=current)
                    UnlexerRule(src=',', parent=current)
            self.ID(parent=current)
            UnlexerRule(src='[', parent=current)
            self.INT(parent=current)
            UnlexerRule(src=']', parent=current)
        elif choice == 2:
            if self._max_depth >= 1:
                for _ in self._model.quantify(current, 2, min=0, max=inf):
                    if self._max_depth >= 1:
                        for _ in self._model.quantify(current, 3, min=0, max=inf):
                            self.ID(parent=current)
                            UnlexerRule(src=',', parent=current)
                    self.ID(parent=current)
                    UnlexerRule(src=',', parent=current)
            self.ID(parent=current)
            UnlexerRule(src='[', parent=current)
            self.INT(parent=current)
            UnlexerRule(src=']', parent=current)
        self._exit_rule(current)
        return current
    mixedlist.min_depth = 1

    @depthcontrol
    def argument(self, parent=None):
        current = UnparserRule(name='argument', parent=parent)
        self._enter_rule(current)
        choice = self._model.choice(current, 0, [0 if [1, 1][i] > self._max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.ID(parent=current)
        elif choice == 1:
            self.ID(parent=current)
            UnlexerRule(src='[', parent=current)
            self.INT(parent=current)
            UnlexerRule(src=']', parent=current)
        self._exit_rule(current)
        return current
    argument.min_depth = 1

    @depthcontrol
    def explist(self, parent=None):
        current = UnparserRule(name='explist', parent=parent)
        self._enter_rule(current)
        if self._max_depth >= 1:
            for _ in self._model.quantify(current, 0, min=0, max=inf):
                self.exp(parent=current)
                UnlexerRule(src=',', parent=current)
        self.exp(parent=current)
        self._exit_rule(current)
        return current
    explist.min_depth = 1

    @depthcontrol
    def exp(self, parent=None):
        current = UnparserRule(name='exp', parent=parent)
        self._enter_rule(current)
        choice = self._model.choice(current, 0, [0 if [2, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1][i] > self._max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.REAL(parent=current)
        elif choice == 1:
            self.INT(parent=current)
        elif choice == 2:
            UnlexerRule(src='pi', parent=current)
        elif choice == 3:
            self.ID(parent=current)
        elif choice == 4:
            self.exp(parent=current)
            UnlexerRule(src='+', parent=current)
            self.exp(parent=current)
        elif choice == 5:
            self.exp(parent=current)
            UnlexerRule(src='-', parent=current)
            self.exp(parent=current)
        elif choice == 6:
            self.exp(parent=current)
            UnlexerRule(src='*', parent=current)
            self.exp(parent=current)
        elif choice == 7:
            self.exp(parent=current)
            UnlexerRule(src='/', parent=current)
            self.exp(parent=current)
        elif choice == 8:
            UnlexerRule(src='-', parent=current)
            self.exp(parent=current)
        elif choice == 9:
            self.exp(parent=current)
            UnlexerRule(src='^', parent=current)
            self.exp(parent=current)
        elif choice == 10:
            UnlexerRule(src='(', parent=current)
            self.exp(parent=current)
            UnlexerRule(src=')', parent=current)
        elif choice == 11:
            self.unaryop(parent=current)
            UnlexerRule(src='(', parent=current)
            self.exp(parent=current)
            UnlexerRule(src=')', parent=current)
        self._exit_rule(current)
        return current
    exp.min_depth = 0

    @depthcontrol
    def unaryop(self, parent=None):
        current = UnparserRule(name='unaryop', parent=parent)
        self._enter_rule(current)
        choice = self._model.choice(current, 0, [0 if [0, 0, 0, 0, 0, 0][i] > self._max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1])])
        if choice == 0:
            UnlexerRule(src='sin', parent=current)
        elif choice == 1:
            UnlexerRule(src='cos', parent=current)
        elif choice == 2:
            UnlexerRule(src='tan', parent=current)
        elif choice == 3:
            UnlexerRule(src='exp', parent=current)
        elif choice == 4:
            UnlexerRule(src='ln', parent=current)
        elif choice == 5:
            UnlexerRule(src='sqrt', parent=current)
        self._exit_rule(current)
        return current
    unaryop.min_depth = 0

    @depthcontrol
    def ID(self, parent=None):
        current = UnlexerRule(name='ID', parent=parent)
        self._enter_rule(current)
        UnlexerRule(src=self._model.charset(current, 0, self._charsets[1]), parent=current)
        if self._max_depth >= 0:
            for _ in self._model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=self._model.charset(current, 1, self._charsets[2]), parent=current)
        self._exit_rule(current)
        return current
    ID.min_depth = 0

    @depthcontrol
    def REAL(self, parent=None):
        current = UnlexerRule(name='REAL', parent=parent)
        self._enter_rule(current)
        self.INT(parent=current)
        UnlexerRule(src='.', parent=current)
        if self._max_depth >= 0:
            for _ in self._model.quantify(current, 0, min=1, max=inf):
                UnlexerRule(src=self._model.charset(current, 0, self._charsets[3]), parent=current)
        if self._max_depth >= 0:
            for _ in self._model.quantify(current, 1, min=0, max=1):
                UnlexerRule(src=self._model.charset(current, 1, self._charsets[4]), parent=current)
                if self._max_depth >= 0:
                    for _ in self._model.quantify(current, 2, min=0, max=1):
                        UnlexerRule(src=self._model.charset(current, 2, self._charsets[5]), parent=current)
                if self._max_depth >= 0:
                    for _ in self._model.quantify(current, 3, min=1, max=inf):
                        UnlexerRule(src=self._model.charset(current, 3, self._charsets[6]), parent=current)
        self._exit_rule(current)
        return current
    REAL.min_depth = 1

    @depthcontrol
    def INT(self, parent=None):
        current = UnlexerRule(name='INT', parent=parent)
        self._enter_rule(current)
        if self._max_depth >= 0:
            for _ in self._model.quantify(current, 0, min=0, max=1):
                UnlexerRule(src=self._model.charset(current, 0, self._charsets[7]), parent=current)
        if self._max_depth >= 0:
            for _ in self._model.quantify(current, 1, min=1, max=inf):
                UnlexerRule(src=self._model.charset(current, 1, self._charsets[8]), parent=current)
        self._exit_rule(current)
        return current
    INT.min_depth = 0

    @depthcontrol
    def WS(self, parent=None):
        current = UnlexerRule(name='WS', parent=parent)
        self._enter_rule(current)
        if self._max_depth >= 0:
            for _ in self._model.quantify(current, 0, min=1, max=inf):
                UnlexerRule(src=self._model.charset(current, 0, self._charsets[9]), parent=current)
        self._exit_rule(current)
        return current
    WS.min_depth = 0

    @depthcontrol
    def COMMENT(self, parent=None):
        current = UnlexerRule(name='COMMENT', parent=parent)
        self._enter_rule(current)
        UnlexerRule(src='/*', parent=current)
        if self._max_depth >= 0:
            for _ in self._model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=self._model.charset(current, 0, self._charsets[0]), parent=current)
        UnlexerRule(src='*/', parent=current)
        self._exit_rule(current)
        return current
    COMMENT.min_depth = 0

    @depthcontrol
    def LINE_COMMENT(self, parent=None):
        current = UnlexerRule(name='LINE_COMMENT', parent=parent)
        self._enter_rule(current)
        UnlexerRule(src='//', parent=current)
        if self._max_depth >= 0:
            for _ in self._model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=self._model.charset(current, 0, self._charsets[10]), parent=current)
        self._exit_rule(current)
        return current
    LINE_COMMENT.min_depth = 0

    _default_rule = mainprog

    _charsets = {
        0: list(itertools.chain.from_iterable([range(32, 127)])),
        1: list(itertools.chain.from_iterable([range(97, 123)])),
        2: list(itertools.chain.from_iterable([range(48, 58), range(65, 91), range(95, 96), range(97, 123)])),
        3: list(itertools.chain.from_iterable([range(48, 58)])),
        4: list(itertools.chain.from_iterable([range(69, 70), range(101, 102)])),
        5: list(itertools.chain.from_iterable([range(43, 44), range(45, 46)])),
        6: list(itertools.chain.from_iterable([range(48, 58)])),
        7: list(itertools.chain.from_iterable([range(43, 44), range(45, 46)])),
        8: list(itertools.chain.from_iterable([range(48, 58)])),
        9: list(itertools.chain.from_iterable([range(9, 10), range(10, 11), range(12, 13), range(13, 14), range(32, 33)])),
        10: list(itertools.chain.from_iterable([range(32, 127)])),
    }
